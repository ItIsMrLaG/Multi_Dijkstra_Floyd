# Реализация алгоритмов Дейкстры и Флойда для нахождения кратчайшего пути

Были реализованы четыре алгоритма и проведены некоторые замеры на случайно сгенерированных графах.
> Корректность параллельных алгоритмов проверялась повторным запуском одних и тех же тестовых наборов и сравнением
> полученных результатов с последовательными версиями.
---

## Реализованные алгоритмы:

* Алгоритм Дейкстры:
    * Последовательная версия
    * Параллельная версия (на основе структуры данных Relaxed-Multi-Queue)
* Алгоритм Флойда–Уоршелла:
    * Последовательная версия
    * Параллельная версия (строчный метод)

---

## Генерация графов:

Генерация графа зависела от следующих параметров:

* Количество вершин
* Количество ребер (их число не могло быть меньше числу вершин - 1, в силу специфики задачи)
* Минимальны/максимальный вес ребра
* Минимальная длина пути между вершинами с 0 индексом и n

Сценарий создания:

* Создаются компоненты связности: (для каждой компоненты)
    * Генерируется случайное остовое дерево
    * Между случайными вершинами добавляются ребра
* Множество вершин пересечения `i`-ой компоненты и `i+1`-ой состоит ровно из одной вершины

## Эксперимент:

> * Проводился на случайно сгенерированных графах разного размера.
> * Замеры производились на 10 запусках
> * Время запуска - среднее арифметическое 10 запусков

### Характеристики вычислительной машины:
> * Процессор: `11th Gen i7-11800H`
> * Объем RAM: `16Gb`
> * ОС: `6.1.80-1-MANJARO`

### Общее сравнение

> Параметры параллельных алгоритмов:
> * Число потоков = 4
>
> Параметры сгенерированных графов:
> * Число вершин = 1000
> * Число ребер = 6500
> * Минимальная длина пути = 100

<table>
  <tr>
    <th>Sequential Dijkstra</th>
    <th>Multi Dijkstra</th>
    <th>Sequential Floyd</th>
    <th>Multi Floyd</th>
  </tr>
  <tr>
    <td>6ms</td>
    <td>36ms</td>
    <td>6096ms</td>
    <td>3226ms</td>
  </tr>
</table>

Из приведенной таблицы становится очевидно, что алгоритм Дейкстры выполняет поставленную задачу эффективнее алгоритма
Флойда–Уоршелла.
> Однако стоит также отметить, что сравнивать два этих алгоритма между собой не очень корректно, потому что алгоритм
> Флойда–Уоршелла позволяет найти решение задачи поиска кратчайшего пути сразу для всех пар вершин, в то время как
> алгоритм Дейкстры находит лишь один минимальный путь между двумя конкретными вершинами. Таким образом любое
> последующее использование алгоритма Флойда–Уоршелла на
> этом же графе будет выполняться за O(1), что гораздо эффективнее алгоритма Дейкстры.

> Рассуждения выше справедливы как для последовательных версиях алгоритмов, так и для параллельных.

### Дейкстры

Эффективность параллельной версии этого алгоритма сильно зависит от графа, внутри которого происходит поиск
кратчайшего пути.

Чтобы пронаблюдать этот эффект сравним время поиска пути на двух графах:

* Случайный граф `10^5` вершин
* Вырожденный граф, где `i`-ая вершина связана ребром только с `i+1`-ой (число вершин = `10^5`)

<table>
  <tr>
    <th>Число потоков</th>
    <th>Вырожденный граф</th>
    <th>Случайный граф</th>
  </tr>
  <tr>
    <td>2</td>
    <td>1040ms</td>
    <td>741ms</td>
  </tr>
  <tr>
    <td>4</td>
    <td>1518ms</td>
    <td>546ms</td>
  </tr>
  <tr>
    <td>8</td>
    <td>2105ms</td>
    <td>363ms</td>
  </tr>
  <tr>
    <td>12</td>
    <td>2518ms</td>
    <td>280ms</td>
  </tr>
  <tr>
    <td>16</td>
    <td>2774ms</td>
    <td>225ms</td>
  </tr>
</table>

Такое поведение вполне ожидаемо,
потому что в **вырожденном** графе в конкретный момент времени внутри
**Relaxed-Multi-Queue** находится только одна вершина. Это в свою очередь влечет за собой работу только одного потока
из `n` возможных.

Кроме того, сравним последовательную и параллельную версию алгоритма на случайном графе (`10^5` вершин).

<table>
  <tr>
    <th>Число потоков</th>
    <th>Sequential Dijkstra</th>
    <th>Multi Dijkstra</th>
  </tr>
  <tr>
    <td>2</td>
    <td>44ms</td>
    <td>741ms</td>
  </tr>
  <tr>
    <td>4</td>
    <td>44ms</td>
    <td>546ms</td>
  </tr>
  <tr>
    <td>8</td>
    <td>42ms</td>
    <td>363ms</td>
  </tr>
  <tr>
    <td>12</td>
    <td>44ms</td>
    <td>280ms</td>
  </tr>
  <tr>
    <td>16</td>
    <td>47ms</td>
    <td>225ms</td>
  </tr>
</table>

Заметно, что параллельная версия гораздо хуже последовательной. Скорее всего, так происходит по двум причинам:

* В силу особенностей параллельного алгоритма, происходит пересчет расстояний до уже обработанных вершин, это замедляет
  работу.
* Особенность обрабатываемого, графа.

### Флойда–Уоршелла

> И параллельный и последовательный алгоритм Флойда–Уоршелла работает с матрицей смежности размер которой равен `n*n`,
> где `n` - число вершин в графе. Из-за этого обрабатывать большие графы, например, на `n = 10^5` вершин, становится
> невозможно.
>
> `10^5*10^5 = 10^10 ~ 10Gb`, столько оперативной памяти довольно тяжело выделить.

В этой работе представлена довольно наивная реализация параллельной версии алгоритма Флойда–Уоршелла, при которой на
каждой итерации самого верхнего цикла происходит создание `n/threadN` потоков, что сильно замедляет работу.
> Используется случайный граф на `1000` вершин.

<table>
  <tr>
    <th>Число потоков</th>
    <th>Sequential Floyd</th>
    <th>Multi Floyd</th>
  </tr>
  <tr>
    <td>2</td>
    <td>5905ms</td>
    <td>4094ms</td>
  </tr>
  <tr>
    <td>4</td>
    <td>5781ms</td>
    <td>2852ms</td>
  </tr>
  <tr>
    <td>8</td>
    <td>5847ms</td>
    <td>3557ms</td>
  </tr>
  <tr>
    <td>10</td>
    <td>5835ms</td>
    <td>4090ms</td>
  </tr>
</table>

> Заметно, что с увеличением числа потоков, эффективность падает. Так происходит из-за того, что на каждой итерации
> приходится выделять `threadN` потоков. А так как итераций всего `n`, то всего надо выделить `n * threadN` потоков. А
> это
> довольно тяжелая операция.
>
> (_Даже несмотря на то, что одновременно запускается только `threadN` потоков_)

Однако параллельный алгоритм все же эффективнее последовательного, даже с такой примитивной реализацией. 
